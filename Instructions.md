# ArchitectAI: Intelligent Design Management Platform
## Product Requirements Document for Cursor Coding Agent Implementation

## Executive Summary
ArchitectAI is an AI-powered design management platform for architectural teams to organize, analyze, and collaborate on complex projects. This PRD provides specific, actionable directives for a cursor coding agent to implement the platform. The system will reduce administrative overhead by 40% through automated file organization, contextual insights, and streamlined collaboration workflows. Target users are small to mid-sized architectural firms managing multiple complex projects.

## 1. Implementation Objectives

### 1.1 Specific Technical Goals
1. Create a Next.js application with App Router that processes and organizes architectural files
2. Implement AI-powered categorization and search for design assets
3. Build a contextual assistant that identifies conflicts and provides design recommendations
4. Develop role-based collaboration tools for architectural workflows
5. Integrate with industry-standard file formats and tools

### 1.2 User Problems to Solve
1. **File Organization**: Architects spend 7.5 hours/week searching for files, with 62% reporting version control issues
2. **Design Context**: 14% of revisions stem from overlooked specifications or conflicts
3. **Stakeholder Communication**: 30% of project time is spent coordinating between clients, contractors, and consultants
4. **Regulatory Compliance**: Architects struggle to maintain awareness of changing building codes and regulations
5. **Knowledge Management**: Critical design decisions and rationales are often lost between project phases

## 2. Technical Requirements

### 2.1 Frontend Stack
- **Framework**: Next.js with App Router
- **UI Library**: Shadcn UI + Tailwind CSS
- **State Management**: 
  - Zustand for UI/application state
  - React Query for server state and data fetching
- **Visualization**: 
  - react-pdf for document viewing
  - @react-three/fiber for 3D models
  - recharts for analytics dashboards
- **File Structure**:
  ```
  app/
    (auth)/
      login/
      register/
    (dashboard)/
      projects/
      [projectId]/
        files/
        insights/
        collaboration/
    api/
      projects/
      files/
      ai/
  components/
    ui/
    projects/
    files/
    collaboration/
  lib/
    supabase/
    ai/
    utils/
  hooks/
    useProject.ts
    useFiles.ts
    useAI.ts
  ```

### 2.2 Backend Implementation
- **Database**: Supabase PostgreSQL with the following schema:
  - `organizations`: id, name, plan_tier, created_at
  - `users`: id, email, name, role, org_id, created_at
  - `projects`: id, name, description, org_id, status, created_at, updated_at
  - `files`: id, name, path, type, size, project_id, version, parent_id, created_by, metadata, created_at
  - `comments`: id, content, file_id, user_id, position_data, created_at
  - `ai_insights`: id, file_id, insight_type, content, created_at, applied_status
  - `workflows`: id, project_id, name, steps, current_step, assignee_id, created_at
  
  **Indexes**:
  - B-tree indexes on frequently filtered fields (project_id, user_id, file_id)
  - GIN indexes on metadata JSONB fields
  - pgvector indexes on embedding columns

- **File Storage**: Supabase Storage with the following buckets:
  - `project-files`: Main storage for all project documents
  - `file-previews`: Generated thumbnails and previews (small, medium, large)
  - `ai-exports`: Exports and reports generated by AI
  - `backup-archives`: Periodic project backups

- **Auth Implementation**: Supabase Auth with JWTs, with these roles:
  - Admin: Full access to organization
  - Project Manager: Full access to assigned projects
  - Architect: Edit access to assigned projects
  - Reviewer: Comment access to assigned projects
  - Client: View access to specific files
  - Contractor: Limited access to construction documentation

- **Serverless Functions**:
  - Edge Functions for high-performance API endpoints
  - Background Functions for long-running tasks (file processing, AI analysis)

### 2.3 AI Implementation
- **RAG Pipeline**: LangChain.js with the following components:
  - DocumentLoaders for PDF, DWG, RVT, and other formats
  - TextSplitters optimized for architectural documents (chunk size: 1000, overlap: 200)
  - OpenAIEmbeddings for vector representation
  - Supabase pgvector for similarity search
  - MetadataFilters for context-aware retrieval

- **LLM Integration**: GPT-4 Turbo with the following parameters:
  - Temperature: 0.2 for technical answers, 0.7 for creative suggestions
  - System prompt focus: architectural domain knowledge, building codes, design principles
  - API implementation with retry logic and fallback models (GPT-3.5-Turbo for less complex tasks)
  - Token usage tracking and optimization strategies
  - Caching of common responses with TTL based on content type

- **Document Processing Flow**:
  1. Upload through resumable.js with configurable chunk size (default 2MB)
  2. Immediate extraction of basic metadata for quick cataloging
  3. Server-side processing queue for text extraction and deeper analysis
  4. Generate embeddings and store in pgvector with regular reindexing
  5. Create preview images at 3 resolutions (thumbnail, medium, large)
  6. Extract key attributes based on file type with format-specific extractors
  7. Periodic background reprocessing for updated AI models

## 3. Core Feature Specifications

### 3.1 File Management System

#### Automatic Classification
- **Implementation**: Multi-label classifier using file content and metadata
- **Categories**: 
  - By Type: Plans, Elevations, Sections, Details, 3D Models, Specifications, Contracts
  - By Phase: Concept, Schematic, Design Development, Construction Documents
  - By Discipline: Architectural, Structural, MEP, Interior, Landscape
- **Storage Pattern**: `/{projectId}/{phase}/{type}/{filename}-v{version}.{ext}`
- **Metadata Extraction**: Extract dimensions, scale, date, author from file headers
- **Large File Handling**: Special processing for files >500MB with streaming extraction
- **Batch Processing**: Support for multi-file uploads with shared metadata

#### Version Control
- **Detection Algorithm**: Compare file names, contents, and modification dates
- **Storage Method**: Keep all versions with parent-child relationships
- **Diff Visualization**: Side-by-side comparison with highlighted changes
- **Timeline Display**: Interactive timeline showing version history with author and changes
- **Merge Capability**: Suggest combining changes from different versions
- **Rollback Functionality**: One-click restoration of previous versions

#### Search Functionality
- **Query Processing**: Parse natural language into structured filters
- **Indexing Strategy**: Full-text search + vector similarity + metadata filtering
- **Result Ranking**: Weighted by recency, relevance, and user access patterns
- **Filter Options**: By file type, date range, author, content keywords, and project phase
- **Saved Searches**: Allow users to save and share complex search queries
- **Search Analytics**: Track common searches to improve system organization

### 3.2 AI Assistant Module

#### Document Q&A
- **Context Window**: Up to 50 pages of relevant documents
- **Prompt Template**:
  ```
  You are an architectural assistant analyzing project {project_name}.
  Answer the following question using only information from these documents:
  {document_context}
  
  Question: {question}
  ```
- **Source Citations**: Include page number and document name for each fact
- **Confidence Scoring**: Indicate low/medium/high confidence based on evidence
- **Progressive Loading**: Stream answers as they're generated
- **Follow-up Detection**: Maintain conversation context for related questions
- **Domain Knowledge**: Supplement with architectural reference information

#### Conflict Detection
- **Processing Steps**:
  1. Extract geometric data from different plan types
  2. Identify spatial overlaps between structural and MEP elements
  3. Check clearance requirements against actual dimensions
  4. Flag potential issues with severity ratings (Critical, Major, Minor)
  5. Track resolution status of identified conflicts
- **Visualization**: Overlay highlights on affected areas with color coding by severity
- **Resolution Suggestions**: Generate 2-3 alternative approaches with pros/cons
- **Conflict History**: Track resolution of conflicts across versions
- **Automated Rechecking**: Verify if new versions resolve previously identified conflicts

#### Code Compliance
- **Supported Codes**: IBC 2021, NFPA 101, ADA Standards, local jurisdiction codes
- **Check Categories**: Egress, accessibility, fire separation, structural requirements, energy efficiency
- **Implementation**: Rule-based system + LLM verification with code reference database
- **Reporting**: Generate compliance report with specific reference to code sections
- **Update Mechanism**: Regular updates to compliance database as codes change
- **Jurisdiction Awareness**: Apply relevant codes based on project location

### 3.3 Collaboration Features

#### Visual Commenting
- **Implementation**: SVG overlay layer on document previews
- **Comment Types**: Text, freehand drawing, measurement, approval stamps
- **Data Structure**: Comment object with coordinates, attachment point, and thread
- **Notifications**: Email + in-app for comment mentions and replies
- **Status Tracking**: Mark comments as Pending, Addressed, or Resolved
- **Filtering**: View comments by user, date, status, or area of document
- **Export**: Generate comment reports for meetings and reviews

#### Approval Workflows
- **States**: Draft → In Review → Approved/Needs Revision
- **Transition Rules**: Configurable by project administrators
- **Approval Actions**: Digital signature capture, timestamp, role verification
- **Audit Trail**: Complete history of document state changes with responsible parties
- **Parallel Workflows**: Support for simultaneous reviews by different stakeholders
- **Conditional Logic**: Set up if/then rules for workflow progression
- **SLA Tracking**: Monitor time in each approval state with alerts for delays

#### Client Portal
- **Interface**: Simplified view optimized for non-technical users
- **Capabilities**: View approved documents, add comments, approve designs
- **Access Control**: Time-limited links with watermarking and download restrictions
- **Feedback Collection**: Structured forms with visual references
- **Decision Tracking**: Record and track client approvals and change requests
- **Mobile Optimization**: Responsive design for on-site reviews
- **White-labeling**: Customizable branding for client-facing interfaces

## 4. Development Phases and Tasks

### Phase 1: Foundation (6 weeks)
1. Initialize Next.js project with TypeScript configuration
   - Set up ESLint, Prettier, and Husky hooks
   - Configure Tailwind and Shadcn UI components
   - Implement responsive layout framework
2. Implement Supabase integration
   - Create database tables with proper relations and constraints
   - Set up storage buckets with security policies
   - Configure authentication with role-based permissions
   - Create API utility functions with error handling
3. Build project dashboard
   - Create project listing with filtering and sorting
   - Implement project creation flow with templates
   - Design basic navigation structure
   - Add project analytics overview

### Phase 2: File Management (8 weeks)
1. Develop file upload system
   - Create drag-and-drop interface with progress indicators
   - Implement chunked uploads for large files
   - Build file type detection and validation
   - Add batch upload functionality
2. Build classification system
   - Train classifier on architectural document samples
   - Implement automatic metadata extraction
   - Create folder suggestion algorithm
   - Develop manual override for classifications
3. Implement version control
   - Develop version comparison visualization
   - Build automated version detection
   - Create version history timeline
   - Implement rollback functionality

### Phase 3: AI Assistant (10 weeks)
1. Set up document processing pipeline
   - Implement text extraction for all supported formats
   - Build chunking and embedding generation
   - Create vector storage and retrieval system
   - Develop metadata filtering system
2. Develop Q&A functionality
   - Design conversational UI for project questions
   - Implement RAG pipeline with source attribution
   - Create feedback mechanism for answer quality
   - Build answer caching for common questions
3. Build conflict detection
   - Implement spatial analysis for plan comparison
   - Create visualization for identified conflicts
   - Develop suggestion generation for resolutions
   - Build conflict tracking system

### Phase 4: Collaboration (8 weeks)
1. Implement commenting system
   - Build annotation layer for document viewer
   - Create threading and notification system
   - Implement mention functionality (@username)
   - Develop comment export and reporting
2. Develop approval workflows
   - Create workflow designer for administrators
   - Implement approval actions and state transitions
   - Build reporting for workflow status
   - Create automatic notifications for approvals
3. Create client portal
   - Design simplified interface for clients
   - Implement secure sharing mechanisms
   - Build feedback collection tools
   - Develop white-labeling capabilities

### Phase 5: Refinement and Optimization (8 weeks)
1. Optimize performance
   - Implement caching strategies for common queries
   - Optimize large file handling
   - Add prefetching for improved navigation
   - Conduct load testing and address bottlenecks
2. Enhance AI capabilities
   - Fine-tune models for architectural domain
   - Improve accuracy of conflict detection
   - Add additional building code support
   - Implement feedback loops for AI improvement
3. Polish user experience
   - Conduct usability testing and implement feedback
   - Refine responsive design for all device sizes
   - Add keyboard shortcuts and accessibility improvements
   - Implement onboarding tutorials and help documentation
4. Implement analytics and reporting
   - Build usage dashboards for administrators
   - Create project progress reporting
   - Develop AI insight effectiveness tracking
   - Design custom report generation

## 5. Technical Integration Points

### 5.1 File Format Support
- **DWG/DXF**: Use AutoCAD Web APIs for preview generation and data extraction
- **RVT**: Use Forge Viewer API for Revit file visualization and element data
- **PDF**: Use pdfplumber for text extraction, pdf.js for viewing
- **SKP**: Use SketchUp API for model viewing
- **IFC**: Use IFC.js for BIM model visualization and data extraction
- **Integration Method**: Server-side processing with format-specific libraries
- **Fallback Handling**: Generic preview generation for unsupported formats

### 5.2 External APIs
- **Building Codes**: Access International Code Council API for regulation updates
- **Materials Database**: Connect to Masterspec API for specifications
- **Sustainability Metrics**: Integrate with EC3 for embodied carbon data
- **Weather Data**: NOAA API for climate analysis and site conditions
- **Authentication**: Implement OAuth for single sign-on with Autodesk, Procore
- **Mapping**: Integration with mapping services for site context
- **Cost Estimation**: Connect to RSMeans or similar for budget forecasting

### 5.3 Performance Optimizations
- **File Processing**: Use Web Workers for client-side operations
- **Image Loading**: Implement progressive loading with blurhash previews
- **API Caching**: Redis cache for frequent queries with context-aware TTL
- **Search Indexing**: Background task queue for document processing
- **3D Viewing**: Level-of-detail rendering based on viewport and device capabilities
- **Lazy Loading**: On-demand component and data loading
- **Static Generation**: Pre-render common pages for faster initial loading
- **CDN Distribution**: Optimize asset delivery through CDN

## 6. Quality Assurance Requirements

### 6.1 Testing Specifications
- **Unit Tests**: Jest with 80% coverage requirement for core modules
- **Integration Tests**: Cypress for critical user flows
- **Performance Tests**: Lighthouse scores (Performance >90, Accessibility >95)
- **AI Quality**: Regular evaluation using architectural test cases with expert review
- **File Formats**: Test suite with sample files of all supported formats and sizes
- **Cross-browser Testing**: Support for Chrome, Firefox, Safari, Edge
- **Mobile Testing**: iPhone, iPad, and Android device compatibility
- **Automated Testing**: CI/CD pipeline with GitHub Actions

### 6.2 Error Handling
- **Frontend Errors**: Error boundaries with fallback UIs and retry mechanisms
- **API Errors**: Structured error responses with error codes and recovery suggestions
- **AI Failures**: Graceful degradation with explanation and alternative paths
- **File Processing**: Retry mechanism with user notification and partial result display
- **Connectivity Issues**: Offline capabilities with synchronization when reconnected
- **Monitoring**: Sentry integration with error grouping, alerts, and resolution tracking
- **User Feedback**: In-app error reporting with screenshot capability

### 6.3 Security Measures
- **Authentication**: PKCE flow with refresh tokens and MFA support
- **Authorization**: Row-level security in Supabase with fine-grained permissions
- **Data Encryption**: TLS in transit, AES-256 at rest for all sensitive data
- **File Scanning**: Malware check before storage with quarantine for suspicious files
- **Audit Logging**: Record all file access and modifications with user attribution
- **Rate Limiting**: Prevent API abuse with tiered rate limits
- **Input Validation**: Server-side validation for all user inputs
- **GDPR Compliance**: Data processing agreements and right-to-be-forgotten support

## 7. Implementation Notes for Cursor Agent

1. Start with the database schema implementation first
2. Focus on file upload and organization before AI features
3. Use TypeScript interfaces for all data structures
4. Implement error handling for all API calls
5. Create reusable components for common UI patterns
6. Use React Server Components for data-fetching pages
7. Implement progressive enhancement for complex features
8. Prioritize responsive design from the beginning
9. Handle large files with chunked processing
10. Document all AI integration points with example prompts
11. Follow naming conventions: PascalCase for components, camelCase for functions/variables
12. Implement feature flags for phased rollout of complex features
13. Create comprehensive logging for debugging and monitoring
14. Build with i18n support from the start, even if initially English-only

## 8. User Experience Considerations

### 8.1 Onboarding Flow
- Welcome tutorial with interactive guided tour
- Template project with sample files for demonstration
- Role-specific onboarding paths (Admin vs. Architect vs. Client)
- Progressive feature introduction to avoid overwhelming new users
- Contextual help tooltips for advanced features

### 8.2 Accessibility
- WCAG 2.1 AA compliance for all interfaces
- Keyboard navigation support for all functions
- Screen reader compatibility with ARIA attributes
- Color contrast ratios meeting accessibility standards
- Alternative text for all visual elements

### 8.3 Localization
- Initial support for English, Spanish, French, German, and Mandarin
- Date, time, and number formatting based on locale
- Right-to-left language support in UI framework
- Translatable error messages and notifications
- Region-specific building code references

### 8.4 Offline Support
- Progressive Web App capabilities for basic functionality without connection
- Offline file viewing for previously accessed documents
- Queued actions that sync when connection is restored
- Clear indication of connection status and offline mode
- Local storage management for offline data

## 9. Analytics and Reporting

### 9.1 Usage Analytics
- Project activity dashboards for administrators
- File access and modification tracking
- Feature adoption metrics across teams
- Time-saved calculations based on automation usage
- AI assistance effectiveness metrics

### 9.2 Business Intelligence
- Project progress visualization
- Resource allocation and utilization reporting
- Bottleneck identification in workflows
- Client engagement metrics
- ROI calculation based on time savings

### 9.3 Export Capabilities
- Project data export in industry-standard formats
- Custom report generation with filtering options
- Scheduled report delivery via email
- Compliance documentation packages
- Archive creation for project handoffs

## Appendix: API Endpoints

### Project API
- `GET /api/projects`: List all projects with pagination and filters
- `POST /api/projects`: Create new project
- `GET /api/projects/{id}`: Get project details
- `PUT /api/projects/{id}`: Update project
- `DELETE /api/projects/{id}`: Delete project
- `GET /api/projects/{id}/stats`: Get project analytics
- `POST /api/projects/{id}/archive`: Create project archive
- `POST /api/projects/{id}/clone`: Clone project structure

### File API
- `GET /api/files`: List files (with filters)
- `POST /api/files/upload`: Upload new file
- `GET /api/files/{id}`: Get file details
- `PUT /api/files/{id}`: Update file metadata
- `DELETE /api/files/{id}`: Delete file
- `GET /api/files/{id}/versions`: List file versions
- `GET /api/files/{id}/preview`: Get file preview
- `POST /api/files/batch`: Batch file operations
- `POST /api/files/{id}/classify`: Manually classify file
- `POST /api/files/{id}/restore`: Restore previous version

### AI API
- `POST /api/ai/query`: Ask question about project
- `POST /api/ai/analyze`: Analyze file for insights
- `POST /api/ai/conflicts`: Detect conflicts between files
- `POST /api/ai/compliance`: Check code compliance
- `POST /api/ai/suggest`: Get design suggestions
- `POST /api/ai/summarize`: Generate project summary
- `POST /api/ai/extract`: Extract structured data from file
- `GET /api/ai/insights/{projectId}`: List all AI insights for project

### Collaboration API
- `POST /api/comments`: Add comment
- `GET /api/comments/{fileId}`: Get comments for file
- `PUT /api/comments/{id}`: Update comment
- `DELETE /api/comments/{id}`: Delete comment
- `POST /api/workflows`: Create approval workflow
- `PUT /api/workflows/{id}/transition`: Update workflow state
- `GET /api/workflows/{projectId}`: List workflows for project
- `POST /api/share`: Create sharing link
- `GET /api/notifications`: Get user notifications
- `PUT /api/notifications/{id}/read`: Mark notification as read

---

*Document Status: Implementation-Ready*  
*Last Updated: February 26, 2025*
*Version: 2.0*
