# ArchitectAI: Intelligent Design Management Platform
## Product Requirements Document for Cursor Coding Agent Implementation

## Executive Summary
ArchitectAI is an AI-powered design management platform for architectural teams to organize, analyze, and collaborate on complex projects. This PRD provides specific, actionable directives for a cursor coding agent to implement the platform. The system will reduce administrative overhead by 40% through automated file organization, contextual insights, and streamlined collaboration workflows. Target users are small to mid-sized architectural firms managing multiple complex projects.

## 1. Implementation Objectives

### 1.1 Specific Technical Goals
1. Create a Next.js application with App Router that processes and organizes architectural files
2. Implement AI-powered categorization and search for design assets
3. Build a contextual assistant that identifies conflicts and provides design recommendations
4. Develop role-based collaboration tools for architectural workflows
5. Integrate with industry-standard file formats and tools

### 1.2 User Problems to Solve
1. **File Organization**: Architects spend 7.5 hours/week searching for files, with 62% reporting version control issues
2. **Design Context**: 14% of revisions stem from overlooked specifications or conflicts
3. **Stakeholder Communication**: 30% of project time is spent coordinating between clients, contractors, and consultants

## 2. Technical Requirements

### 2.1 Frontend Stack
- **Framework**: Next.js with App Router
- **UI Library**: Shadcn UI + Tailwind CSS
- **State Management**: Zustand for application state
- **Visualization**: react-pdf for document viewing, @react-three/fiber for 3D models
- **File Structure**:
  ```
  app/
    (auth)/
      login/
      register/
    (dashboard)/
      projects/
      [projectId]/
        files/
        insights/
        collaboration/
    api/
      projects/
      files/
      ai/
  components/
    ui/
    projects/
    files/
    collaboration/
  lib/
    supabase/
    ai/
    utils/
  ```

### 2.2 Backend Implementation
- **Database**: Supabase PostgreSQL with the following schema:
  - `organizations`: id, name, plan_tier, created_at
  - `users`: id, email, name, role, org_id, created_at
  - `projects`: id, name, description, org_id, created_at, updated_at
  - `files`: id, name, path, type, size, project_id, version, parent_id, created_by, created_at
  - `comments`: id, content, file_id, user_id, position_data, created_at
  - `ai_insights`: id, file_id, insight_type, content, created_at

- **File Storage**: Supabase Storage with the following buckets:
  - `project-files`: Main storage for all project documents
  - `file-previews`: Generated thumbnails and previews
  - `ai-exports`: Exports and reports generated by AI

- **Auth Implementation**: Supabase Auth with JWTs, with these roles:
  - Admin: Full access to organization
  - Project Manager: Full access to assigned projects
  - Architect: Edit access to assigned projects
  - Reviewer: Comment access to assigned projects
  - Client: View access to specific files

### 2.3 AI Implementation
- **RAG Pipeline**: LangChain.js with the following components:
  - DocumentLoaders for PDF, DWG, RVT, and other formats
  - TextSplitters optimized for architectural documents (chunk size: 1000, overlap: 200)
  - OpenAIEmbeddings for vector representation
  - Supabase pgvector for similarity search

- **LLM Integration**: GPT-4 Turbo with the following parameters:
  - Temperature: 0.2 for technical answers, 0.7 for creative suggestions
  - System prompt focus: architectural domain knowledge, building codes, design principles
  - API implementation with retry logic and fallback models

- **Document Processing Flow**:
  1. Upload through resumable.js with chunks of 2MB
  2. Server-side processing to extract text and metadata
  3. Generate embeddings and store in pgvector
  4. Create preview images at 3 resolutions (thumbnail, medium, large)
  5. Extract key attributes based on file type

## 3. Core Feature Specifications

### 3.1 File Management System

#### Automatic Classification
- **Implementation**: Multi-label classifier using file content and metadata
- **Categories**: 
  - By Type: Plans, Elevations, Sections, Details, 3D Models, Specifications, Contracts
  - By Phase: Concept, Schematic, Design Development, Construction Documents
- **Storage Pattern**: `/{projectId}/{phase}/{type}/{filename}-v{version}.{ext}`
- **Metadata Extraction**: Extract dimensions, scale, date, author from file headers

#### Version Control
- **Detection Algorithm**: Compare file names, contents, and modification dates
- **Storage Method**: Keep all versions with parent-child relationships
- **Diff Visualization**: Side-by-side comparison with highlighted changes
- **Timeline Display**: Interactive timeline showing version history with author and changes

#### Search Functionality
- **Query Processing**: Parse natural language into structured filters
- **Indexing Strategy**: Full-text search + vector similarity
- **Result Ranking**: Weighted by recency, relevance, and user access patterns
- **Filter Options**: By file type, date range, author, content keywords, and project phase

### 3.2 AI Assistant Module

#### Document Q&A
- **Context Window**: Up to 50 pages of relevant documents
- **Prompt Template**:
  ```
  You are an architectural assistant analyzing project {project_name}.
  Answer the following question using only information from these documents:
  {document_context}
  
  Question: {question}
  ```
- **Source Citations**: Include page number and document name for each fact
- **Confidence Scoring**: Indicate low/medium/high confidence based on evidence

#### Conflict Detection
- **Processing Steps**:
  1. Extract geometric data from different plan types
  2. Identify spatial overlaps between structural and MEP elements
  3. Check clearance requirements against actual dimensions
  4. Flag potential issues with severity ratings
- **Visualization**: Overlay highlights on affected areas
- **Resolution Suggestions**: Generate 2-3 alternative approaches with pros/cons

#### Code Compliance
- **Supported Codes**: IBC 2021, NFPA 101, ADA Standards
- **Check Categories**: Egress, accessibility, fire separation, structural requirements
- **Implementation**: Rule-based system + LLM verification
- **Reporting**: Generate compliance report with specific reference to code sections

### 3.3 Collaboration Features

#### Visual Commenting
- **Implementation**: SVG overlay layer on document previews
- **Comment Types**: Text, freehand drawing, measurement, approval stamps
- **Data Structure**: Comment object with coordinates, attachment point, and thread
- **Notifications**: Email + in-app for comment mentions and replies

#### Approval Workflows
- **States**: Draft → In Review → Approved/Needs Revision
- **Transition Rules**: Configurable by project administrators
- **Approval Actions**: Digital signature capture, timestamp, role verification
- **Audit Trail**: Complete history of document state changes with responsible parties

#### Client Portal
- **Interface**: Simplified view optimized for non-technical users
- **Capabilities**: View approved documents, add comments, approve designs
- **Access Control**: Time-limited links with watermarking
- **Feedback Collection**: Structured forms with visual references

## 4. Development Phases and Tasks

### Phase 1: Foundation (6 weeks)
1. Initialize Next.js project with TypeScript configuration
   - Set up ESLint, Prettier, and Husky hooks
   - Configure Tailwind and Shadcn UI components
2. Implement Supabase integration
   - Create database tables with proper relations and constraints
   - Set up storage buckets with security policies
   - Configure authentication with role-based permissions
3. Build project dashboard
   - Create project listing with filtering and sorting
   - Implement project creation flow with templates
   - Design basic navigation structure

### Phase 2: File Management (6 weeks)
1. Develop file upload system
   - Create drag-and-drop interface with progress indicators
   - Implement chunked uploads for large files
   - Build file type detection and validation
2. Build classification system
   - Train classifier on architectural document samples
   - Implement automatic metadata extraction
   - Create folder suggestion algorithm
3. Implement version control
   - Develop version comparison visualization
   - Build automated version detection
   - Create version history timeline

### Phase 3: AI Assistant (8 weeks)
1. Set up document processing pipeline
   - Implement text extraction for all supported formats
   - Build chunking and embedding generation
   - Create vector storage and retrieval system
2. Develop Q&A functionality
   - Design conversational UI for project questions
   - Implement RAG pipeline with source attribution
   - Create feedback mechanism for answer quality
3. Build conflict detection
   - Implement spatial analysis for plan comparison
   - Create visualization for identified conflicts
   - Develop suggestion generation for resolutions

### Phase 4: Collaboration (8 weeks)
1. Implement commenting system
   - Build annotation layer for document viewer
   - Create threading and notification system
   - Implement mention functionality (@username)
2. Develop approval workflows
   - Create workflow designer for administrators
   - Implement approval actions and state transitions
   - Build reporting for workflow status
3. Create client portal
   - Design simplified interface for clients
   - Implement secure sharing mechanisms
   - Build feedback collection tools

### Phase 5: Refinement (8 weeks)
1. Optimize performance
   - Implement caching strategies for common queries
   - Optimize large file handling
   - Add prefetching for improved navigation
2. Enhance AI capabilities
   - Fine-tune models for architectural domain
   - Improve accuracy of conflict detection
   - Add additional building code support
3. Polish user experience
   - Conduct usability testing and implement feedback
   - Refine responsive design for all device sizes
   - Add keyboard shortcuts and accessibility improvements

## 5. Technical Integration Points

### 5.1 File Format Support
- **DWG/DXF**: Use AutoCAD Web APIs for preview generation
- **RVT**: Use Forge Viewer API for Revit file visualization
- **PDF**: Use pdfplumber for text extraction, pdf.js for viewing
- **SKP**: Use SketchUp API for model viewing
- **Integration Method**: Server-side processing with format-specific libraries

### 5.2 External APIs
- **Building Codes**: Access International Code Council API
- **Materials Database**: Connect to Masterspec API for specifications
- **Sustainability Metrics**: Integrate with EC3 for embodied carbon data
- **Weather Data**: NOAA API for climate analysis
- **Authentication**: Implement OAuth for single sign-on with Autodesk, Procore

### 5.3 Performance Optimizations
- **File Processing**: Use Web Workers for client-side operations
- **Image Loading**: Implement progressive loading with blurhash previews
- **API Caching**: Redis cache for frequent queries with 15-minute TTL
- **Search Indexing**: Background task queue for document processing
- **3D Viewing**: Level-of-detail rendering based on viewport

## 6. Quality Assurance Requirements

### 6.1 Testing Specifications
- **Unit Tests**: Jest with 80% coverage requirement
- **Integration Tests**: Cypress for critical user flows
- **Performance Tests**: Lighthouse scores (Performance >90, Accessibility >95)
- **AI Quality**: Regular evaluation using architectural test cases
- **File Formats**: Test suite with sample files of all supported formats

### 6.2 Error Handling
- **Frontend Errors**: Error boundaries with fallback UIs
- **API Errors**: Structured error responses with error codes
- **AI Failures**: Graceful degradation with explanation
- **File Processing**: Retry mechanism with user notification
- **Monitoring**: Sentry integration with error grouping and alerts

### 6.3 Security Measures
- **Authentication**: PKCE flow with refresh tokens
- **Authorization**: Row-level security in Supabase
- **Data Encryption**: TLS in transit, AES-256 at rest
- **File Scanning**: Malware check before storage
- **Audit Logging**: Record all file access and modifications

## 7. Implementation Notes for Cursor Agent

1. Start with the database schema implementation first
2. Focus on file upload and organization before AI features
3. Use TypeScript interfaces for all data structures
4. Implement error handling for all API calls
5. Create reusable components for common UI patterns
6. Use React Server Components for data-fetching pages
7. Implement progressive enhancement for complex features
8. Prioritize responsive design from the beginning
9. Handle large files with chunked processing
10. Document all AI integration points with example prompts

## Appendix: API Endpoints

### Project API
- `GET /api/projects`: List all projects
- `POST /api/projects`: Create new project
- `GET /api/projects/{id}`: Get project details
- `PUT /api/projects/{id}`: Update project
- `DELETE /api/projects/{id}`: Delete project

### File API
- `GET /api/files`: List files (with filters)
- `POST /api/files/upload`: Upload new file
- `GET /api/files/{id}`: Get file details
- `PUT /api/files/{id}`: Update file metadata
- `DELETE /api/files/{id}`: Delete file
- `GET /api/files/{id}/versions`: List file versions
- `GET /api/files/{id}/preview`: Get file preview

### AI API
- `POST /api/ai/query`: Ask question about project
- `POST /api/ai/analyze`: Analyze file for insights
- `POST /api/ai/conflicts`: Detect conflicts between files
- `POST /api/ai/compliance`: Check code compliance

### Collaboration API
- `POST /api/comments`: Add comment
- `GET /api/comments/{fileId}`: Get comments for file
- `POST /api/workflows`: Create approval workflow
- `PUT /api/workflows/{id}/transition`: Update workflow state
- `POST /api/share`: Create sharing link

---

*Document Status: Implementation-Ready*  
*Last Updated: February 26, 2025*
